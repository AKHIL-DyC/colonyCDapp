# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

input TokenFromEverywhereArguments {
  tokenAddress: String!
}

input CreateUniqueUserInput {
  id: ID!
  name: String!
  profile: ProfileInput
}

enum EmailPermissions {
  sendNotifications
  isHuman
}

input ProfileMetadataInput {
  emailPermissions: [String!]!
}

input MetadataInput {
  network: Network
  chainId: Int
}

input NativeTokenStatusInput {
  unlocked: Boolean
  mintable: Boolean
  unlockable: Boolean
}

input ColonyStatusInput {
  nativeToken: NativeTokenStatusInput
  recovery: Boolean
}

input CreateUniqueColonyInput {
  id: ID!
  name: String!
  colonyNativeTokenId: ID!
  profile: ProfileInput
  type: ColonyType
  status: ColonyStatusInput
  meta: MetadataInput
}

input ProfileInput {
  id: ID # nullable since resolver will use User / Colony id by default
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail
  meta: ProfileMetadataInput
}

input CreateUniqueDomainInput {
  colonyAddress: ID!
  parentId: ID
  name: String
  description: String
  color: DomainColor
}

input GetUserReputationInput {
  walletAddress: String!
  colonyAddress: String!
  domainId: Int
  rootHash: String
}

type TokenFromEverywhereReturn {
  items: [Token]
}

input GetReputationForTopDomainsInput {
  walletAddress: String!
  colonyAddress: String!
  rootHash: String
}

type UserDomainReputation {
  domainId: Int!
  reputationPercentage: String!
}

type GetReputationForTopDomainsReturn {
  items: [UserDomainReputation!]
}

enum TokenType {
  COLONY
  ERC20
}

enum Network {
  GANACHE
  MAINNET
  GOERLI
  GNOSIS
  GNOSISFORK
}

enum DomainColor {
  LIGHTPINK
  PINK
  BLACK
  EMERALDGREEN
  BLUE
  YELLOW
  RED
  GREEN
  PERIWINKLE
  GOLD
  AQUA
  BLUEGREY
  PURPLE
  ORANGE
  MAGENTA
  PURPLEGREY
}

enum ColonyType {
  COLONY
  METACOLONY
}

type Query {
  getTokenFromEverywhere(
    input: TokenFromEverywhereArguments
  ): TokenFromEverywhereReturn @function(name: "fetchTokenFromChain")
  getReputationForTopDomains(
    input: GetReputationForTopDomainsInput
  ): GetReputationForTopDomainsReturn @function(name: "getReputationForTopDomains")
  getUserReputation(
    input: GetUserReputationInput
  ): String @function(name: "getUserReputation")
}

type Mutation {
  createUniqueUser(
    input: CreateUniqueUserInput
  ): User @function(name: "createUniqueUser")
  createUniqueColony(
    input: CreateUniqueColonyInput
  ): ColonyID @function(name: "createUniqueColony")
  createUniqueDomain(
    input: CreateUniqueDomainInput
  ): Domain @function(name: "createUniqueDomain")
}

# Applies to both Users and Colonies
# Might need to separate it into two later down the line
type Profile @model {
  id: ID!
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail @index(name: "byEmail", queryField: "getProfileByEmail")
  meta: ProfileMetadata

}

type NativeTokenStatus {
  unlocked: Boolean # If it's already unlocked
  mintable: Boolean # User has permissions to mint new tokens
  unlockable: Boolean # Token can be unlocked
}

type ColonyStatus {
  nativeToken: NativeTokenStatus
  recovery: Boolean # if it's in recovery mode
}

# Applies to both Colonies and Tokens
# It does not apply to user accounts as they can live on all networks
type Metadata {
  network: Network
  chainId: Int
}

type ProfileMetadata {
  emailPermissions: [String!]!
}

type Token @model {
  id: ID! @index(name: "byAddress", queryField: "getTokenByAddress") # contract address
  name: String!
  symbol: String!
  decimals: Int!
  type: TokenType @index(name: "byType", queryField: "getTokensByType")
  colonies: [Colony] @manyToMany(relationName: "ColonyTokens")
  users: [User] @manyToMany(relationName: "UserTokens")
  avatar: String
  thumbnail: String
  meta: Metadata
}

type ColonyID {
  id: ID!
}

type Colony @model {
  id: ID! @index(name: "byAddress", queryField: "getColonyByAddress") # contract address
  name: String! @index(name: "byName", queryField: "getColonyByName")
  nativeToken: Token! @hasOne
  tokens: [Token] @manyToMany(relationName: "ColonyTokens")
  profileId: ID
  profile: Profile @hasOne(fields: ["profileId"])
  status: ColonyStatus
  domains: [Domain] @hasMany
  transactions: [ColonyTransaction] @hasMany
  watchers: [User] @manyToMany(relationName: "WatchedColonies") # colony subscriptions
  type: ColonyType @index(name: "byType", queryField: "getColonyByType")
  meta: Metadata
  balances: [ColonyBalance] @hasMany
}

type User @model {
  id: ID! @index(name: "byAddress", queryField: "getUserByAddress") # wallet address
  name: String! @index(name: "byName", queryField: "getUserByName")
  tokens: [Token] @manyToMany(relationName: "UserTokens")
  profileId: ID
  profile: Profile @hasOne(fields: ["profileId"])
  watchlist: [Colony] @manyToMany(relationName: "WatchedColonies") # colony subscriptions
}

type Domain @model {
  id: ID! @index(name: "byNativeId", sortKeyFields: ["nativeId"]) # colonyAddress_nativeId
  nativeId: Int!
  name: String
  description: String
  color: DomainColor
  parent: Domain @hasOne
}

type TransactionArguments {
  source: String
  amount: String
}

type ColonyTransaction @model {
  # Needed a manual index on the id field so that we can delcare the sort fields
  # This allows us to sort by the creation date, between date ranges,
  # and a whole lot of other combinations of that
  id: ID! @index(sortKeyFields: ["createdAt"]) # chainId_transactionHash_logIndex
  token: Token! @hasOne
  createdAtBlock: Int!
  # DynamoDB is stupid!!
  # For future reference do be aware that you can't index non-scalar types,
  # and from those scalar types, you can't index Booleans (for some reason)
  # Meaning that if you have a true/false check that you whish to filter by
  # in your query, make sure to make it a string :(
  claimed: String @index @default(value: "false")
  args: TransactionArguments
  # This is a native field that gets added automatically behind the scenes
  # to all model types
  # However, we need it for sorting, so need to explicitly declare it
  createdAt: AWSDateTime!
}

type ColonyBalance @model (queries: null) {
  id: ID!
  domain: Domain! @hasOne
  token: Token! @hasOne
  balance: String! @default(value: "0")
}


# mutation MyMutation {
#   createColonyBalance(
#     input: {
#       domainNativeId: 2,
#       balance: "99999999",
#       colonyBalanceDomainId: "0x3a157280ca91bB49dAe3D1619C55Da7F9D4438c3_2", -- domain id
#       colonyBalanceTokenId: "0xD1518B721A797b860Ba61bF7cDB4B8A4C4720ef3", -- token address
#       colonyBalancesId: "0x3a157280ca91bB49dAe3D1619C55Da7F9D4438c3"  -- colony address
#     }
#   ) {
#     id
#   }
# }

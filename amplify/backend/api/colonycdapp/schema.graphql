# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
# NOTE: This file is getting out hand in terms of size
# There is an official way of splitting the schema into multiple files
# https://docs.amplify.aws/cli-legacy/graphql-transformer/overview/#api-category-project-structure
# but I never could get it to work

"""
Input data for fetching a token's information from DB or chain.
"""
input TokenFromEverywhereArguments {
  """Address of the token on the blockchain."""
  tokenAddress: String!
}

"""
Input data for fetching the list of members for a specific Colony.
"""
input MembersForColonyInput {
  """Address of the Colony."""
  colonyAddress: String!
  """Root hash for the reputation state."""
  rootHash: String
  """ID of the domain within the Colony."""
  domainId: Int
  """Sorting method to apply to the member list."""
  sortingMethod: SortingMethod
}

"""
Input data for creating a unique user within the Colony Network. Use this instead of the automatically generated `CreateUserInput` input type.
"""
input CreateUniqueUserInput {
  """Unique identifier for the user. This is the user's wallet address."""
  id: ID!
  """The username."""
  name: String!
  """Profile data for the user."""
  profile: ProfileInput
}

"""
**Deprecated** Extra permissions for a user, stored during the registration process.
"""
enum EmailPermissions {
  """Permission to send notifications to the user."""
  sendNotifications
  """Person is registered and solved the captcha, they can use gasless transactions."""
  isHuman
}

"""
Input data for a user's profile metadata.
"""
input ProfileMetadataInput {
  """List of email permissions for the user."""
  emailPermissions: [String!]!
}

"""
Input data for relevant chain metadata of a Colony (if applicable).
"""
input ChainMetadataInput {
  """The network the Colony is deployed on."""
  network: Network
  """The chain ID of the network."""
  chainId: Int!
  """The transaction hash of the creation transaction."""
  transactionHash: String
  """The log index of the creation transaction."""
  logIndex: Int
  """The block number of the creation transaction."""
  blockNumber: Int
}

"""
Input data for the status of a Colony's native token.

Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later.
"""
input NativeTokenStatusInput {
  """Whether the native token is unlocked."""
  unlocked: Boolean
  """Whether the native token is mintable."""
  mintable: Boolean
  """Whether the native token can be unlocked."""
  unlockable: Boolean
}

"""
Input data for a Colony's status information.

This is set when a Colony is created and can be changed later.
"""
input ColonyStatusInput {
  """Status information for the Colony's native token."""
  nativeToken: NativeTokenStatusInput
  """Whether the Colony is in recovery mode."""
  recovery: Boolean
}

"""
Input data for creating a unique Colony within the Colony Network. Use this instead of the automatically generated `CreateColonyInput` input type.
"""
input CreateUniqueColonyInput {
  """Unique identifier for the Colony. This is the Colony's contract address."""
  id: ID!
  """Display name of the Colony."""
  name: String!
  """Unique identifier for the Colony's native token (this is its address)."""
  colonyNativeTokenId: ID!
  """Type of the Colony (regular or MetaColony)."""
  type: ColonyType
  """Status information for the Colony."""
  status: ColonyStatusInput
  """Metadata related to the Colony's creation on the blockchain."""
  chainMetadata: ChainMetadataInput!
  """Version of the currently deployed Colony contract."""
  version: Int!
}

"""
Input data to use when creating or changing a user profile
"""
input ProfileInput {
  """The unique identifier for the user profile."""
  id: ID
  """The URL of the user's avatar image."""
  avatar: String
  """The URL of the user's thumbnail image."""
  thumbnail: String
  """The display name of the user."""
  displayName: String
  """A short description or biography of the user."""
  bio: String
  """The user's location (e.g., city or country)."""
  location: String
  """The user's personal or professional website."""
  website: AWSURL
  """The user's email address."""
  email: AWSEmail
  """Any additional metadata or settings related to the user profile."""
  meta: ProfileMetadataInput
}

"""
Input data for a user's reputation within a Domain in a Colony. If no `domainId` is passed, the Root Domain is used.
A `rootHash` can be provided, to get reputation at a certain point in the past.
"""
input GetUserReputationInput {
  """The Ethereum wallet address of the user."""
  walletAddress: String!
  """The Ethereum address of the Colony."""
  colonyAddress: String!
  """The ID of the Domain within the Colony. If not provided, defaults to the Root Domain."""
  domainId: Int
  """The root hash of the reputation tree at a specific point in time."""
  rootHash: String
}

"""
Input data for updating an extension's information within a Colony, based on the Colony ID and extension hash.
The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
"""
input UpdateExtensionByColonyAndHashInput {
  """The unique identifier for the Colony."""
  colonyId: ID!
  """The hash of the extension to be updated."""
  hash: String!
  """A flag to indicate whether the extension is deprecated."""
  isDeprecated: Boolean
  """A flag to indicate whether the extension is deleted."""
  isDeleted: Boolean
  """A flag to indicate whether the extension is initialized."""
  isInitialized: Boolean
  """The version of the extension."""
  version: Int
  """The Ethereum address of the user who installed the extension."""
  installedBy: String
  """The timestamp when the extension was installed."""
  installedAt: AWSTimestamp
}

"""
Input data to store the latest available version of the core Colony contract and available extensions

The extension hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network (e.g. `VotingReputation`)
"""
input SetCurrentVersionInput {
  """COLONY for the Colony contract, extension hash for extensions"""
  key: String!
  """Latest available version"""
  version: Int!
}

"""
Return type for tokens gotten from DB or from chain.
"""
type TokenFromEverywhereReturn {
  """List of tokens found"""
  items: [Token]
}

"""
Input data for retrieving a user's reputation within the top domains of a Colony.
"""
input GetReputationForTopDomainsInput {
  """The wallet address of the user."""
  walletAddress: String!
  """The address of the Colony."""
  colonyAddress: String!
  """The root hash of the reputation tree at a specific point in time."""
  rootHash: String
}

"""
Input data for retrieving a user's token balance for a specific token.
"""
input GetUserTokenBalanceInput {
  """The wallet address of the user."""
  walletAddress: String!
  """The Colony address"""
  colonyAddress: String!
  """The address of the token."""
  tokenAddress: String!
}

input GetMotionStateInput {
  colonyAddress: String!
  databaseMotionId: String!
  transactionHash: String!
}

input GetVoterRewardsInput {
  voterAddress: String!
  colonyAddress: String!
  nativeMotionDomainId: String!
  motionId: String!
  rootHash: String!
}

input GetMotionTimeoutPeriodsInput {
  motionId: String!
  colonyAddress: String!
}

"""
A type representing a user's reputation within a domain.
"""
type UserDomainReputation {
  """The integer ID of the Domain within the Colony."""
  domainId: Int!
  """The user's reputation within the domain, represented as a percentage."""
  reputationPercentage: String!
}

"""
A return type that contains an array of UserDomainReputation items.
"""
type GetReputationForTopDomainsReturn {
  """An array of UserDomainReputation items."""
  items: [UserDomainReputation!]
}

"""
A return type representing the breakdown of a user's token balance.
"""
type GetUserTokenBalanceReturn {
  """The total token balance, including inactive, locked, and active balances."""
  balance: String
  """
  The inactive portion of the user's token balance.
  This is the balance of a token that is in a users wallet but can't be used by the Colony Network (e.g. for governance).
  """
  inactiveBalance: String
  """
  The locked portion of the user's token balance.
  This is the balance of a token that is staked (e.g. in motions).
  """
  lockedBalance: String
  """
  The active portion of the user's token balance.
  This is the balance that is approved for the Colony Network to use (e.g. for governance).
  """
  activeBalance: String
  """
  The pending portion of the user's token balance.
  These are tokens that have been sent to the wallet, but are inaccessible until all locks are cleared and then these tokens are claimed.
  """
  pendingBalance: String
}

type GetMotionTimeoutPeriodsReturn {
  timeLeftToStake: String!
  timeLeftToVote: String!
  timeLeftToReveal: String!
  timeLeftToEscalate: String!
}

"""
A return type representing the members of a Colony.

Definitions:
* Member = User watching a Colony, with or without reputation
* Contributor = User watching a Colony WITH reputation
* Watcher = User watching a Colony WITHOUT reputation
"""
type MembersForColonyReturn {
  """User watching a Colony WITH reputation"""
  contributors: [Contributor!]
  """User watching a Colony WITHOUT reputation"""
  watchers: [Watcher!]
}

type VoterRewardsReturn {
  min: String!
  max: String!
  reward: String!
}

"""
Variants of different token types a Colony can use.
As Colonies can use multiple tokens and even own tokens (BYOT), we need to differentiate.
"""
enum TokenType {
  """A (ERC20-compatible) token that was deployed with Colony. It has a few more features, like minting through the Colony itself"""
  COLONY
  """An ERC20-compatible token"""
  ERC20
  """The native token of the Chain used (e.g. ETH on mainnet or xDAI on Gnosis-Chain)"""
  CHAIN_NATIVE
}


"""
Variants of supported Ethereum networks.
"""
enum Network {
  """Local development network using Ganache."""
  GANACHE
  """Ethereum Mainnet."""
  MAINNET
  """Ethereum Goerli test network."""
  GOERLI
  """Gnosis Chain network."""
  GNOSIS
  """Fork of Gnosis Chain for QA purposes."""
  GNOSISFORK
}

"""
Variants of available domain colors as used in the dApp.
"""
enum DomainColor {
  """A light pink color."""
  LIGHT_PINK
  """A pink color."""
  PINK
  """A black color."""
  BLACK
  """An emerald green color."""
  EMERALD_GREEN
  """A blue color."""
  BLUE
  """A yellow color."""
  YELLOW
  """A red color."""
  RED
  """A green color."""
  GREEN
  """A pale indigo color."""
  PERIWINKLE
  """A gold color."""
  GOLD
  """An aqua color."""
  AQUA
  """A blue-grey(ish) color."""
  BLUE_GREY
  """A purple color."""
  PURPLE
  """An orange color."""
  ORANGE
  """A magenta color."""
  MAGENTA
  """A purple-grey(ish) color."""
  PURPLE_GREY
}

"""
Variants of Colony types.
"""
enum ColonyType {
  """A regular Colony."""
  COLONY
  """The MetaColony, which governs the entire Colony Network."""
  METACOLONY
}

"""
Variants of Colony Network blockchain events.

These can all happen in a Colony and will be interpreted by the dApp according to their types.
"""
enum ColonyActionType {
  """A generic or unspecified Colony action."""
  GENERIC
  NULL_MOTION
  """An action unrelated to the currently viewed Colony. """
  WRONG_COLONY
  """An action related to a payment within a Colony."""
  PAYMENT
  PAYMENT_MOTION
  """An action related to the recovery functionality of a Colony."""
  RECOVERY
  """An action related to moving funds between domains."""
  MOVE_FUNDS
  MOVE_FUNDS_MOTION
  """An action related to unlocking a token within a Colony."""
  UNLOCK_TOKEN
  UNLOCK_TOKEN_MOTION
  """An action related to minting tokens within a Colony."""
  MINT_TOKENS
  MINT_TOKENS_MOTION
  """An action related to creating a domain within a Colony."""
  CREATE_DOMAIN
  CREATE_DOMAIN_MOTION
  """An action related to upgrading a Colony's version."""
  VERSION_UPGRADE
  VERSION_UPGRADE_MOTION
  """An action related to editing a Colony's details."""
  COLONY_EDIT
  COLONY_EDIT_MOTION
  """An action related to editing a domain's details."""
  EDIT_DOMAIN
  EDIT_DOMAIN_MOTION
  """An action related to setting user roles within a Colony."""
  SET_USER_ROLES
  SET_USER_ROLES_MOTION
  """An action related to a domain reputation penalty within a Colony (smite)."""
  EMIT_DOMAIN_REPUTATION_PENALTY
  EMIT_DOMAIN_REPUTATION_PENALTY_MOTION
  """An action related to a domain reputation reward within a Colony."""
  EMIT_DOMAIN_REPUTATION_REWARD
  EMIT_DOMAIN_REPUTATION_REWARD_MOTION
}

"""
Variants of sorting methods for a member list.
"""
enum SortingMethod {
  """Sort members by highest reputation."""
  BY_HIGHEST_REP
  """Sort members by lowest reputation."""
  BY_LOWEST_REP
  """Sort members by having more permissions."""
  BY_MORE_PERMISSIONS
  """Sort members by having fewer permissions."""
  BY_LESS_PERMISSIONS
}

"""Root query type."""
type Query {
  """Fetch a token's information. Tries to get the data from the DB first, if that fails, resolves to get data from chain"""
  getTokenFromEverywhere(
    input: TokenFromEverywhereArguments
  ): TokenFromEverywhereReturn @function(name: "fetchTokenFromChain-${env}")
  """Retrieve a user's reputation within the top domains of a Colony."""
  getReputationForTopDomains(
    input: GetReputationForTopDomainsInput
  ): GetReputationForTopDomainsReturn
    @function(name: "getReputationForTopDomains-${env}")
  """Retrieve a user's reputation within a specific domain in a Colony."""
  getUserReputation(input: GetUserReputationInput): String
    @function(name: "getUserReputation-${env}")
  """Retrieve a user's token balance for a specific token."""
  getUserTokenBalance(
    input: GetUserTokenBalanceInput
  ): GetUserTokenBalanceReturn @function(name: "getUserTokenBalance-${env}")
  """Fetch the list of members for a specific Colony."""
  getMembersForColony(input: MembersForColonyInput): MembersForColonyReturn
    @function(name: "getMembersForColony-${env}")
  getMotionState(input: GetMotionStateInput): Int!
    @function(name: "fetchMotionState-${env}")
  getVoterRewards(input: GetVoterRewardsInput): VoterRewardsReturn
    @function(name: "fetchVoterRewards-${env}")
  getMotionTimeoutPeriods(
    input: GetMotionTimeoutPeriodsInput
  ): GetMotionTimeoutPeriodsReturn
    @function(name: "fetchMotionTimeoutPeriods-${env}")
}

"""
Root mutation type.
"""
type Mutation {
  """Create a unique user within the Colony Network. Use this instead of the automatically generated `createUser` mutation"""
  createUniqueUser(input: CreateUniqueUserInput): User
    @function(name: "createUniqueUser-${env}")
  """Create a unique Colony within the Colony Network. Use this instead of the automatically generate `createColony` mutation"""
  createUniqueColony(input: CreateUniqueColonyInput): Colony
    @function(name: "createUniqueColony-${env}")
  """Updates the latest available version of a Colony or an extension"""
  setCurrentVersion(input: SetCurrentVersionInput): Boolean
    @function(name: "setCurrentVersion-${env}")
  """
  Update an extension's details for a specific Colony.

  The extension hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network (e.g. `VotingReputation`)
  """
  updateExtensionByColonyAndHash(
    input: UpdateExtensionByColonyAndHashInput
  ): ColonyExtension @function(name: "updateExtensionByColonyAndHash-${env}")
}

"""
Represents a user's profile within the Colony Network.
"""
type Profile @model {
  """Unique identifier for the user's profile."""
  id: ID!
  """URL of the user's avatar image."""
  avatar: String
  """URL of the user's thumbnail image."""
  thumbnail: String
  """Display name of the user."""
  displayName: String
  """User's bio information."""
  bio: String
  """User's location information."""
  location: String
  """URL of the user's website."""
  website: AWSURL
  """User's email address."""
  email: AWSEmail @index(name: "byEmail", queryField: "getProfileByEmail")
  """Metadata associated with the user's profile."""
  meta: ProfileMetadata
}

"""
Represents the status of a Colony's native token.

Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later.
"""
type NativeTokenStatus {
  """Whether the native token is unlocked."""
  unlocked: Boolean
  """Whether the user has permissions to mint new tokens."""
  mintable: Boolean
  """Whether the native token can be unlocked."""
  unlockable: Boolean
}

"""
Represents the status of a Colony.

This contains important meta information about the Colony's token and other fundamental settings
"""
type ColonyStatus {
  """Status information for the Colony's native token."""
  nativeToken: NativeTokenStatus
  """Whether the Colony is in recovery mode."""
  recovery: Boolean
}

"""
Represents metadata related to a blockchain event.

Applies to Colonies, Tokens and Events, but not all fields are revlant to all
It does not apply to user accounts as they can live on all networks
"""
type ChainMetadata {
  """The network the event occurred on."""
  network: Network
  """The chain ID of the event."""
  chainId: Int!
  """The transaction hash of the event."""
  transactionHash: String
  """The log index of the event."""
  logIndex: Int
  """The block number of the event."""
  blockNumber: Int
}

"""
Represents metadata for a user's profile. Mostly user specific settings.
"""
type ProfileMetadata {
  """List of email permissions for the user."""
  emailPermissions: [String!]!
}

"""
Represents a contributor within the Colony Network.

A contributor is a Colony member who has reputation.
"""
type Contributor {
  """Wallet address of the contributor."""
  address: String!
  """User data associated with the contributor."""
  user: User
  """Reputation percentage of the contributor (of all reputation within the Colony)."""
  reputationPercentage: String
  """Reputation amount of the contributor (as an absolute number)."""
  reputationAmount: String
}

"""
Represents a watcher within the Colony Network.

A watcher is a Colony member who doesn't have reputation.
"""
type Watcher {
  """Wallet address of the watcher."""
  address: String!
  """User data associated with the watcher."""
  user: User
}

"""Represents an ERC20-compatible token that is used by Colonies and users."""
type Token @model {
  """Unique identifier for the token (contract address)."""
  id: ID!
    @index(name: "byAddress", queryField: "getTokenByAddress")
    @index(sortKeyFields: ["createdAt"]) # contract address
  """Name of the token."""
  name: String!
  """Symbol of the token."""
  symbol: String!
  """Decimal precision of the token."""
  decimals: Int!
  """Type of the token. See `TokenType` for more information"""
  type: TokenType @index(name: "byType", queryField: "getTokensByType")
  """List of colonies using the token."""
  colonies: [Colony] @manyToMany(relationName: "ColonyTokens")
  """List of users using the token."""
  users: [User] @manyToMany(relationName: "UserTokens")
  """URL of the token's avatar image (logo)."""
  avatar: String
  """URL of the token's thumbnail image (Small logo)."""
  thumbnail: String
  """Metadata related to the chain of the token."""
  chainMetadata: ChainMetadata!
  """Timestamp of the token model's creation in the database."""
  createdAt: AWSDateTime!
}

"""
Represents a Colony within the Colony Network.
"""
type Colony @model {
  """Unique identifier for the Colony (contract address)."""
  id: ID! @index(name: "byAddress", queryField: "getColonyByAddress")
  """(Short) name of the Colony."""
  name: String! @index(name: "byName", queryField: "getColonyByName")
  """The unique address of the native token of the Colony."""
  nativeTokenId: ID!
    @index(name: "byNativeTokenId", queryField: "getColoniesByNativeTokenId")
  """The native token of the Colony."""
  nativeToken: Token! @hasOne(fields: ["nativeTokenId"])
  """List of tokens that are used within the Colony."""
  tokens: [Token] @manyToMany(relationName: "ColonyTokens")
  """Status information for the Colony."""
  status: ColonyStatus
  """List of domains of the Colony."""
  domains: [Domain] @hasMany(indexName: "byColony", fields: ["id"])
  """List of users watching the Colony."""
  watchers: [User] @manyToMany(relationName: "WatchedColonies")
  """List of Colony funds claims for all ERC20 tokens."""
  # NOTE: Could not merge these two fields properly
  # Ideally we would merge data from these two into one field, but I couldn't do that
  # meaning we'll have to merge this data in-app (or not at all, works either way)
  # If you have a better idea, on how to merged them, I'll all ears..
  fundsClaims: [ColonyFundsClaim] @hasMany
  """List of native chain token claims (e.g., Token 0x0000...0000: ETH, xDAI, etc.)."""
  # This is not an array since only a single token type can be returned
  chainFundsClaim: ColonyChainFundsClaim
    @function(name: "fetchColonyNativeFundsClaim-${env}")
  """Type of the Colony (Regular or Metacolony)."""
  type: ColonyType @index(name: "byType", queryField: "getColonyByType")
  """Returns a list token balances for each domain and each token that the colony has."""
  balances: ColonyBalances @function(name: "fetchColonyBalances-${env}")
  """Metadata related to the chain of the Colony."""
  chainMetadata: ChainMetadata!
  """List of extensions installed in the Colony."""
  extensions: [ColonyExtension!] @hasMany(indexName: "byColony", fields: ["id"])
  """Version of the Colony."""
  version: Int!
  """List of actions that happened within the Colony."""
  actions: [ColonyAction] @hasMany
  """List of motions within the Colony that have unclaimed stakes."""
  motionsWithUnclaimedStakes: [ColonyUnclaimedStake!]
  """Metadata of the Colony."""
  metadata: ColonyMetadata @hasOne(fields: ["id"])
  """List of all roles within the Colony"""
  # @TODO This should not be fetched upfront
  # It should be retrieved on demand at the earliest occasion it's needed
  # ie: when opening a UAC modal
  roles: [ColonyRole] @hasMany
}

type ColonyUnclaimedStake {
  motionId: String! # database id
  unclaimedRewards: [StakerRewards!]!
}

type PendingModifiedTokenAddresses {
  added: [String!]
  removed: [String!]
}

"""
Represents metadata for a Colony.
"""
type ColonyMetadata @model {
  """Unique identifier for the Colony (contract address)."""
  id: ID!
  """Display name of the Colony."""
  displayName: String!
  """URL of the Colony's avatar image."""
  avatar: String
  """URL of the Colony's thumbnail image."""
  thumbnail: String
  """List of Colony metadata changelog entries."""
  changelog: [ColonyMetadataChangelog!]
  isWhitelistActivated: Boolean
  whitelistedAddresses: [String!]
  modifiedTokenAddresses: PendingModifiedTokenAddresses # only present on pendingColonyMetadata for consumption in block ingestor
}

"""
Represents a changelog entry for Colony metadata.

This is used to traverse through the history of metadata values and consolidate them into a final state.
"""
type ColonyMetadataChangelog {
  """Transaction hash associated with the changelog entry."""
  transactionHash: String!
  """Display name of the Colony before the change."""
  oldDisplayName: String!
  """Display name of the Colony after the change."""
  newDisplayName: String!
  """Indicates whether the avatar has changed."""
  hasAvatarChanged: Boolean!
  hasWhitelistChanged: Boolean!
  haveTokensChanged: Boolean!
}

"""
Represents a User within the Colony Network.
"""
type User @model {
  """Unique identifier for the user (wallet address)."""
  id: ID! @index(name: "byAddress", queryField: "getUserByAddress")
  """(Short) name of the user."""
  name: String! @index(name: "byName", queryField: "getUserByName")
  """List of tokens the user is using."""
  tokens: [Token] @manyToMany(relationName: "UserTokens")
  """Profile ID associated with the user."""
  profileId: ID
  """Profile information of the user."""
  profile: Profile @hasOne(fields: ["profileId"])
  """List of Colonies the user is watching."""
  watchlist: [Colony] @manyToMany(relationName: "WatchedColonies") # colony subscriptions
  """List of stakes the User made"""
  stakes: [ColonyStake!]! @hasMany(indexName: "byUserAddress", fields: ["id"])
}

# Keeps track of the current amount a user has staked in a colony
# When a user stakes, totalAmount increases. When a user reclaims their stake, totalAmount decreases.
type ColonyStake @model {
  id: ID! # <userId>_<colonyId>
  userId: ID!
    @index(
      name: "byUserAddress"
      queryField: "getColonyStakeByUserAddress"
      sortKeyFields: ["colonyId"]
    )
  colonyId: ID!
  totalAmount: String!
}

"""
Represents a Domain within the Colony Network.
"""
type Domain @model {
  """
  Unique identifier for the Domain.

  This should be in the following format: `colonyAddress_nativeId`
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  # Has to be self-managed
  id: ID!
  """Colony ID associated with the Domain."""
  colonyId: ID! @index(name: "byColony")
  """Colony associated with the Domain."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  Native ID of the Domain.

  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  nativeId: Int!
  """
  Native funding pot ID of the Domain.

  The native funding pot ID is assigned to a domain from the contract on creation
  """
  nativeFundingPotId: Int!
  """
  Native skill ID of the Domain.

  The native skill ID is assigned to a domain from the contract on creation
  """
  nativeSkillId: Int!
  """Indicates whether the Domain is the root domain (ID 1)"""
  isRoot: Boolean!
  """Metadata of the Domain."""
  metadata: DomainMetadata @hasOne(fields: ["id"])
}

"""
Represents metadata for a Domain.
"""
type DomainMetadata @model {
  """
  Unique identifier for the Domain metadata.
  This field is referenced by Domain id, so has to be in the same format: colonyAddress_nativeId
  """
  id: ID!
  """Name of the Domain."""
  name: String!
  """Description of the Domain."""
  description: String!
  """Color associated with the Domain."""
  color: DomainColor!
  """List of Domain metadata changelog entries."""
  changelog: [DomainMetadataChangelog!]
}

"""
Represents a changelog entry for Domain metadata.
"""
type DomainMetadataChangelog {
  """Transaction hash associated with the changelog entry."""
  transactionHash: String!
  """Name of the Domain before the change."""
  oldName: String!
  """Name of the Domain after the change."""
  newName: String!
  """Color of the Domain before the change."""
  oldColor: DomainColor!
  """Color of the Domain after the change."""
  newColor: DomainColor!
  """Description of the Domain before the change."""
  oldDescription: String!
  """Description of the Domain after the change."""
  newDescription: String!
}

"""
Represents a Colony Funds Claim for all ERC20 tokens (except native chain tokens)
"""
type ColonyFundsClaim @model {
  """Unique identifier for the Colony Funds Claim."""
  id: ID! @index(sortKeyFields: ["createdAt"])
  """Token associated with the Colony Funds Claim."""
  token: Token! @hasOne
  """Block number when the Funds Claim was created."""
  createdAtBlock: Int!
  """Timestamp when the Funds Claim was created."""
  createdAt: AWSDateTime!
  """Amount claimed in the Colony Funds Claim."""
  amount: String!
}

"""
Represents a native Colony Chain Funds Claim

E.g., Token 0x0000...0000: ETH, xDAI, etc.
"""
type ColonyChainFundsClaim {
  """Unique identifier for the Colony Chain Funds Claim."""
  id: ID!
  """Block number when the Chain Funds Claim was created."""
  createdAtBlock: Int!
  """Timestamp when the Chain Funds Claim was created."""
  createdAt: AWSDateTime!
  """Timestamp when the Chain Funds Claim was last updated."""
  updatedAt: AWSDateTime!
  """Amount claimed in the Colony Chain Funds Claim."""
  amount: String!
}

"""
Represents a Colony balance for a specific domain and token.
"""
# This is not a @model since it will only be returned by a lambda function
# so don't need to create tables for them
# Note that we also need input types since it treats the `balances` as available
# to "write" to at creation time, even though, even if you were to write to
# you'd never actually be able to read that data since the return is overwritten
# by the lambda function
type ColonyBalance {
  """Unique identifier for the Colony Balance."""
  id: ID!
  """Balance of the specific token in the domain."""
  balance: String!
  """Domain associated with the Colony Balance."""
  domain: Domain
  """
  Token associated with the Colony Balance.
  Note that for the chain native token, name and symbol are empty.
  """
  token: Token!
}

"""Represents a collection of Colony balances."""
type ColonyBalances {
  """List of Colony balances."""
  items: [ColonyBalance]
}

"""Input type for specifying a Domain."""
input DomainInput {
  """Unique identifier for the Domain."""
  id: ID!
}

"""Input type for specifying a Token."""
input TokenInput {
  """Unique identifier for the Token."""
  id: ID!
}

input MotionStakeValuesInput {
  yay: String!
  nay: String!
}

type MotionStakeValues {
  yay: String!
  nay: String!
}

input MotionStakesInput {
  raw: MotionStakeValuesInput!
  percentage: MotionStakeValuesInput!
}

type MotionStakes {
  raw: MotionStakeValues!
  percentage: MotionStakeValues!
}

input UserStakesInput {
  address: String!
  stakes: MotionStakesInput!
}

type UserStakes {
  address: String!
  stakes: MotionStakes!
}

input StakerRewardsInput {
  address: String!
  rewards: MotionStakeValuesInput!
  isClaimed: Boolean!
}

type StakerRewards {
  address: String!
  rewards: MotionStakeValues!
  isClaimed: Boolean!
}

input VoterRecordInput {
  address: String!
  voteCount: String!
  vote: Int # nullable since we don't know the vote until it's revealed
}

type VoterRecord {
  address: String!
  voteCount: String!
  vote: Int # nullable since we don't know the vote until it's revealed
}

input MotionMessageInput {
  initiatorAddress: String!
  name: String!
  messageKey: String!
  vote: String
  amount: String
}

type MotionMessage @model {
  initiatorAddress: ID!
  name: String!
  messageKey: String!
  motionId: ID!
    @index(
      name: "byMotionId"
      queryField: "getMotionMessageByMotionId"
      sortKeyFields: ["createdAt"]
    )
  initiatorUser: User @hasOne(fields: ["initiatorAddress"])
  vote: String
  amount: String
  createdAt: AWSDateTime!
}

input MotionStateHistoryInput {
  hasVoted: Boolean!
  hasPassed: Boolean!
  hasFailed: Boolean!
  hasFailedNotFinalizable: Boolean!
  inRevealPhase: Boolean!
}

type MotionStateHistory {
  hasVoted: Boolean!
  hasPassed: Boolean!
  hasFailed: Boolean!
  hasFailedNotFinalizable: Boolean!
  inRevealPhase: Boolean!
}

type ColonyMotion @model {
  id: ID! # to ensure uniqueness, we format as: chainId-votingRepExtnAddress_nativeMotionId
  nativeMotionId: String!
  usersStakes: [UserStakes!]!
  stakerRewards: [StakerRewards!]!
  motionStakes: MotionStakes!
  remainingStakes: [String!]! # tuple [nayRemaining, yayRemaining]
  userMinStake: String!
  requiredStake: String!
  rootHash: String! # For calculating user's max stake in client
  motionDomainId: ID! # domain db id
  motionDomain: Domain! @hasOne(fields: ["motionDomainId"])
  nativeMotionDomainId: String! # native domain id
  isFinalized: Boolean!
  createdBy: String! # voting rep extn address. Useful to check if we're viewing a "read-only" motion
  voterRecord: [VoterRecord!]!
  revealedVotes: MotionStakes! ## I.e. MotionVotes (same type)
  repSubmitted: String!
  skillRep: String!
  hasObjection: Boolean!
  motionStateHistory: MotionStateHistory!
  messages: [MotionMessage!]! @hasMany(indexName: "byMotionId", fields: ["id"])
}

"""
Represents an event triggered by a smart contract within the Colony Network.
"""
# This will store the relevant events we care about for a particular colony
# Altough it might also hold events emmited by other clients (eg: network or token)
# but are event pertaining to a colony
# Generally you'd want to use this from a block ingenstor, after you've processed
# data from an event, also save that even for future use
type ContractEvent @model {
  """
  Unique identifier for the Contract Event, in the format chainID_transactionHash_logIndex.
  """
  id: ID!
  """Name of the event."""
  # i'm debating if this should be a enum or not, but this was you don't have to
  # update this schema every time you want to start tracking a new event
  name: String!
  """The unique signature of the event."""
  signature: String!
  """Metadata associated with the event's chain."""
  chainMetadata: ChainMetadata!
  """Optional association with a Colony."""
  colony: Colony @hasOne
  """Optional association with a Token."""
  token: Token @hasOne
  """Optional association with a Domain."""
  domain: Domain @hasOne
  """Optional association with a User."""
  user: User @hasOne
  """Address of the agent who initiated the event."""
  agent: String!
  """Address of the target contract on the receiving end of the event."""
  target: String!
  """Optional encoded arguments as a JSON string."""
  encodedArguments: String
}

type VotingReputationParams {
  totalStakeFraction: String!
  voterRewardFraction: String!
  userMinStakeFraction: String!
  maxVoteFraction: String!
  stakePeriod: String!
  submitPeriod: String!
  revealPeriod: String!
  escalationPeriod: String!
}

# Parameters an extension is initialised with, e.g VotingRepExtn
type ExtensionParams {
  votingReputation: VotingReputationParams
}

"""
Represents a single extension installed on a Colony.
"""
type ColonyExtension @model {
  """Unique identifier for the ColonyExtension."""
  id: ID!
  """The identifier of the Colony that the extension belongs to (the Colony's address)"""
  colonyId: ID!
    @index(
      name: "byColony"
      sortKeyFields: ["hash"]
      queryField: "getExtensionByColonyAndHash"
    )
  """The Colony that the extension belongs to."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  The unique hash of the extension.

  The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
  """
  hash: String! @index(name: "byHash", queryField: "getExtensionsByHash")
  """The address of the user who installed the extension."""
  installedBy: String!
  """The timestamp when the extension was installed."""
  installedAt: AWSTimestamp!
  """Indicates whether the extension is deprecated."""
  isDeprecated: Boolean!
  """Indicates whether the extension has been removed."""
  isDeleted: Boolean!
  """Indicates whether the extension has been initialized."""
  isInitialized: Boolean!
  """The version number of the extension."""
  version: Int!
  params: ExtensionParams
}

"""Represents the current version of an entity in the system."""
type CurrentVersion @model {
  """Unique identifier for the CurrentVersion."""
  id: ID!
  """The key used to look up the current version."""
  key: String! @index(name: "byKey", queryField: "getCurrentVersionByKey")
  """The current version number."""
  version: Int!
}

type CurrentNetworkInverseFee @model {
  id: ID!
  inverseFee: String!
}

"""Represents an action performed within a Colony."""
type ColonyAction @model {
  """Unique identifier for the ColonyAction."""
  id: ID!
  """The identifier of the Colony that the action belongs to."""
  colonyId: ID!
    @index(
      name: "byColony"
      queryField: "getActionsByColony"
      sortKeyFields: ["createdAt"]
    )
  """The Colony that the action belongs to."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """The type of action performed."""
  type: ColonyActionType!
  """The block number where the action was recorded."""
  blockNumber: Int!
  isMotion: Boolean
  motionId: ID
    @index(name: "byMotionId", queryField: "getColonyActionByMotionId")
  motionData: ColonyMotion @hasOne(fields: ["motionId"])
  showInActionsList: Boolean! # True for (forced) actions. True for motions if staked above 10%
  """The timestamp when the action was created."""
  createdAt: AWSDateTime!
  """The Ethereum address of the action initiator. Can be a user, extension or colony."""
  initiatorAddress: ID!

  # Action type specific fields which might be null

  # Amplify will automatically populate one of the following fields with related model if there is an initiator
  """The User who initiated the action, if applicable."""
  initiatorUser: User @hasOne(fields: ["initiatorAddress"])
  """The ColonyExtension that initiated the action, if applicable."""
  initiatorExtension: ColonyExtension @hasOne(fields: ["initiatorAddress"])
  """The Colony that initiated the action, if applicable."""
  initiatorColony: Colony @hasOne(fields: ["initiatorAddress"])
  initiatorToken: Token @hasOne(fields: ["initiatorAddress"])

  # Amplify will automatically populate one of the following fields with related model if there is an recipient
  """The Ethereum address of the action recipient, if applicable."""
  recipientAddress: ID
  """The User who received the action, if applicable."""
  recipientUser: User @hasOne(fields: ["recipientAddress"])
  recipientColony: Colony @hasOne(fields: ["recipientAddress"])
  recipientExtension: ColonyExtension @hasOne(fields: ["recipientAddress"])
  recipientToken: Token @hasOne(fields: ["recipientAddress"])

  """The amount involved in the action, if applicable."""
  amount: String
  """The Ethereum address of the token involved in the action, if applicable."""
  tokenAddress: ID
  """The Token involved in the action, if applicable."""
  token: Token @hasOne(fields: ["tokenAddress"])
  """The source Domain identifier, if applicable."""
  fromDomainId: ID
  """The source Domain of the action, if applicable."""
  fromDomain: Domain @hasOne(fields: ["fromDomainId"])
  """The target Domain identifier, if applicable."""
  toDomainId: ID
  """The target Domain of the action, if applicable."""
  toDomain: Domain @hasOne(fields: ["toDomainId"])
  """The fundamental chain id"""
  fundamentalChainId: Int
  """The resulting new Colony version, if applicable."""
  newColonyVersion: Int
  pendingDomainMetadataId: ID
  pendingDomainMetadata: DomainMetadata
    @hasOne(fields: ["pendingDomainMetadataId"])
  pendingColonyMetadataId: ID
  pendingColonyMetadata: ColonyMetadata
    @hasOne(fields: ["pendingColonyMetadataId"])
  motionDomainId: Int
  roles: ColonyActionRoles

  # Required since some actions might have multiple event entries in the list
  # which need to be iterated over and exposed individually
  #
  # This should be a list/array, but this is yet another thing Amplify is bad at
  # The official response from them is to use DynamoDB directly:
  # https://stackoverflow.com/questions/50992106/append-item-to-list-using-aws-appsync-to-dynamodb
  # Which is just freaking great!
  #
  # As such, I've decided to simplify this, an just pass a stringified JSON around
  # since this is for display purpouses only.
  #
  # If anyone has a better idea on how to handle this, I'll gladly change it!
  #
  # When / if you decide to use it, just be mindful of what format other people
  # are using, and follow suit.
  #
  # Roles Types:
  # [{ id: String, type: String, role: Number, setTo: boolean }]
  individualEvents: String
}

type ColonyActionRoles {
  role_0: Boolean # recovery
  role_1: Boolean # root
  role_2: Boolean # arbitration
  role_3: Boolean # architecture
  role_5: Boolean # funding
  role_6: Boolean # administration
}

# Roles have been set as role_<number> so we can more easily map them to their
# actual contract counterpart on the client and block ingestor side(s)

type ColonyRole @model {
  id: ID! @index # colonyAddress_domainNativeId_userAddress_roles
  domainId: ID!
  domain: Domain! @hasOne(fields: ["domainId"])

  targetAddress: ID # Amplify will automatically populate one of the following fields with related model if it finds one
  targetUser: User @hasOne(fields: ["targetAddress"])
  targetColony: Colony @hasOne(fields: ["targetAddress"])
  targetExtension: ColonyExtension @hasOne(fields: ["targetAddress"])
  targetToken: Token @hasOne(fields: ["targetAddress"])

  latestBlock: Int!
  role_0: Boolean # recovery
  role_1: Boolean # root
  role_2: Boolean # arbitration
  role_3: Boolean # architecture
  role_5: Boolean # funding
  role_6: Boolean # administration
}

# it's a model, not a type since this is designed to work outside of the main
# colony model, or colony role model, as, by design it should be only used
# in very specific cases
#
# This should take a snapshot of the user's full roles/permissions at a specific block

type ColonyHistoricRole @model {
  id: ID! # colonyAddress_domainNativeId_userAddress_blockNumber_roles
  # I HATE AMPLIFY SORTING! MAY IT DIE A THOUSAND DEATHS!
  #
  # @NOTE Always set to `type` to "SortedHistoricRole" to enable Amplify sorting, it DOES NOT WORK with `id`
  #
  # Apparently, it can only filter non-primary fields, meaning that if we sort by `blockNumber` then that
  # field is considered primary, so it won't allow us to filter by it.
  # To overcome this we've sorted by creation date, which is not really correct from a block chain
  # point of view, but due to the nature of the block ingestor, it works for our use case
  type: String!
    @index(
      name: "getColonyHistoricRoleByDate"
      queryField: "getColonyHistoricRoleByDate"
      sortKeyFields: ["createdAt"]
    )

  domainId: ID!
  domain: Domain! @hasOne(fields: ["domainId"])
  colonyId: ID!
  colony: Colony! @hasOne(fields: ["colonyId"])

  targetAddress: ID # Amplify will automatically populate one of the following fields with related model if it finds one
  targetUser: User @hasOne(fields: ["targetAddress"])
  targetColony: Colony @hasOne(fields: ["targetAddress"])
  targetExtension: ColonyExtension @hasOne(fields: ["targetAddress"])
  targetToken: Token @hasOne(fields: ["targetAddress"])

  blockNumber: Int!
  role_0: Boolean # recovery
  role_1: Boolean # root
  role_2: Boolean # arbitration
  role_3: Boolean # architecture
  role_5: Boolean # funding
  role_6: Boolean # administration
  createdAt: AWSDateTime!
}

# Model storing block ingestor stats, as key-value entries
type IngestorStats @model {
  id: ID!
  value: String!
}
